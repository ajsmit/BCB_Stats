<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Scratch</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="scratch_files/libs/clipboard/clipboard.min.js"></script>
<script src="scratch_files/libs/quarto-html/quarto.js"></script>
<script src="scratch_files/libs/quarto-html/popper.min.js"></script>
<script src="scratch_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="scratch_files/libs/quarto-html/anchor.min.js"></script>
<link href="scratch_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="scratch_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="scratch_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="scratch_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="scratch_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Scratch</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>To consider:</p>
<p>Nomenclature… Glossary…</p>
<p><strong>To include…</strong></p>
<p>Key considerations for each method::</p>
<ul>
<li><strong>R Functions and Packages:</strong> To provide the R functions and packages that can be used to perform the statistical analysis.</li>
<li><strong>Data Type:</strong> The type of your outcome variable (continuous, categorical, count, etc.) is crucial for selecting the appropriate model.</li>
<li><strong>Research Question:</strong> Are you interested in prediction, hypothesis testing, or both?</li>
<li><strong>Sample Size:</strong> The size of your sample can influence the choice of statistical method.</li>
<li><strong>Examples:</strong> Real-world, locally-relevant examples to demonstrate how to apply statistical methods to data.</li>
<li><strong>Assumptions:</strong> Each statistical method has underlying assumptions that should be checked before applying the model.</li>
<li><strong>Alternatives:</strong> If the assumptions of a parametric method are violated, consider non-parametric alternatives.</li>
<li><strong>Model Complexity:</strong> Choose a model that is sufficiently complex to capture the relationships in your data but not so complex that it overfits the data.</li>
</ul>
<p><strong>To cover in some detail in Chapters</strong></p>
<ul>
<li><strong>Confidence Regions and Confidence Intervals</strong></li>
</ul>
<p><strong>Chapters</strong></p>
<ul>
<li>t-tests</li>
<li>ANOVA</li>
<li>MANCOVA</li>
<li>Z-test</li>
<li>Comparison test?</li>
<li>ANCOVA</li>
<li>Chi-square</li>
<li>Wilcoxon’s test</li>
<li>Mann-Whitney U test</li>
<li>Kruskal-Wallis test</li>
<li>Kolmogorov-Smirnov test</li>
<li>Kendall’s W test</li>
<li>Friedman test</li>
<li>Fisher’s test</li>
<li>Sign test</li>
<li>Binomial test</li>
<li>McNemar test</li>
<li>Correlations (Pearson’s, Spearmans’s Kendal tau)</li>
<li>Regression (linear, logistic, Poisson, beta)</li>
<li>Non-linear regression</li>
<li>Hierarchical models</li>
<li>Mixed models</li>
<li>Assumption tests
<ul>
<li>Normality</li>
<li>etc.</li>
</ul></li>
</ul>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>If the research question involves understanding, quantifying, or predicting the relationship between a response variable and one or more predictor variables, then regression-based methods would be more appropriate. Regression models allow for estimating the effect of predictors on the response variable, assessing the strength and significance of the relationships, making predictions or forecasts based on the predictor values, and exploring linear and non-linear relationships while handling different types of response variables.</p>
</section>
<section id="regression-decision-diagram" class="level2">
<h2 class="anchored" data-anchor-id="regression-decision-diagram">Regression decision diagram</h2>
<section id="start-with-the-research-question-and-data-characteristics" class="level3">
<h3 class="anchored" data-anchor-id="start-with-the-research-question-and-data-characteristics">1. Start with the Research Question and Data Characteristics</h3>
<ul>
<li>What is the nature of your response/dependent variable?
<ul>
<li>Continuous: Proceed to Linear Models (Section 2) or Non-Linear Models (Section 5) if linearity assumption is violated.</li>
<li>Binary (Yes/No): Consider Logistic Regression (Section 3).</li>
<li>Count data: Explore Generalized Linear Models (GLMs) (Section 4).</li>
<li>Proportions or percentages: Consider Beta Regression (Section 4).</li>
</ul></li>
<li>Are you interested in prediction, explanation, or simply assessing the strength of a relationship?
<ul>
<li>Prediction: Linear, generalised linear, and non-linear models are suitable.</li>
<li>Explanation: Consider models that allow for interpretation of coefficients and relationships.</li>
<li>Strength of relationship: Correlation (Section 7), linear, and generalised linear models can be used.</li>
</ul></li>
</ul>
</section>
<section id="linear-models-for-continuous-outcomes" class="level3">
<h3 class="anchored" data-anchor-id="linear-models-for-continuous-outcomes">2. Linear Models for Continuous Outcomes</h3>
<p>Linear models assume a linear relationship between the predictors and the continuous response variable.</p>
<section id="simple-linear-regression-slr" class="level4">
<h4 class="anchored" data-anchor-id="simple-linear-regression-slr">2.1. Simple Linear Regression (SLR)</h4>
<ul>
<li><strong>R Function:</strong> <code>lm()</code></li>
<li><strong>Data Requirements:</strong> Continuous outcome, one continuous predictor.</li>
<li><strong>Assumptions:</strong> Normality, homoscedasticity of residuals, linearity.</li>
<li><strong>Diagnostics:</strong> Check residual plots, normality of residuals, and leverage/influence points.</li>
<li><strong>If Assumptions Fail:</strong> Transformations (e.g., log, square root), robust regression (<code>rlm()</code> in MASS package), or consider non-linear models (Section 5).</li>
</ul>
<p>The following aspects to be included:</p>
<p><strong>Model Validation and Selection:</strong> Introduce techniques for model validation, such as cross-validation or bootstrapping, to assess how well the model generalizes to new data. Discuss criteria for model selection, like adjusted R-squared or information criteria (AIC, BIC), to compare different models and choose the most appropriate one.</p>
<p><strong>Outliers and Influential Points:</strong> Explain how to identify outliers and influential points using diagnostic plots (e.g., Cook’s distance) or statistical tests. Discuss strategies for dealing with these points, such as robust regression or data transformation, and the potential impact on model results.</p>
<p><strong>Practical Considerations:</strong> Provide guidance on experimental design for simple linear regression, including sample size determination, choice of predictor variables, and potential confounding factors. Discuss the importance of domain knowledge in interpreting regression results and making informed decisions based on the model.</p>
<p><strong>Extensions and Limitations:</strong> Briefly mention extensions of simple linear regression, such as weighted least squares for heteroscedasticity or segmented regression for non-linear relationships. Discuss the limitations of simple linear regression, emphasizing the importance of checking assumptions and considering alternative models when necessary.</p>
</section>
<section id="multiple-linear-regression-mlr" class="level4">
<h4 class="anchored" data-anchor-id="multiple-linear-regression-mlr">2.2. Multiple Linear Regression (MLR)</h4>
<ul>
<li><strong>R Function:</strong> <code>lm()</code></li>
<li><strong>Data Requirements:</strong> Continuous outcome, multiple predictors (continuous or categorical).</li>
<li><strong>Assumptions:</strong> Same as SLR, plus no multicollinearity.</li>
<li><strong>Diagnostics:</strong> Same as SLR, plus check for multicollinearity (e.g., VIF).</li>
<li><strong>If Assumptions Fail:</strong> Same as SLR. Consider interactions or polynomial terms.</li>
<li><strong>Model Selection:</strong> Stepwise regression, regularization techniques (e.g., LASSO, Ridge), information criteria (AIC, BIC).</li>
</ul>
<p>Additional Information to Include</p>
<ol start="2" type="1">
<li><strong>Categorical Predictors with More Than Two Levels</strong>:
<ul>
<li>Expand the discussion of categorical predictors to cover those with multiple levels (using dummy variables or effect coding).</li>
<li>Explain how to interpret the coefficients for different coding schemes.</li>
</ul></li>
<li><strong>Model Selection Criteria</strong>:
<ul>
<li>Discuss alternative approaches to forward selection, such as backward elimination or stepwise regression.</li>
<li><strong>AIC (Akaike Information Criterion)</strong>: Introduce AIC and explain how it’s used in model selection.</li>
<li><strong>BIC (Bayesian Information Criterion)</strong>: Compare AIC with BIC and discuss their use.</li>
<li><strong>Adjusted R-squared</strong>: Explain the adjusted R-squared and how it differs from the R-squared.</li>
<li>Introduce the concept of cross-validation for assessing model performance and avoiding overfitting.</li>
</ul></li>
<li><strong>Dealing with Outliers and Influential Points</strong>:
<ul>
<li><strong>Robust Regression</strong>: Provide an overview of robust regression techniques as an alternative to handle outliers.</li>
</ul></li>
<li><strong>Predictive Modelling</strong>:
<ul>
<li>Dedicate a section to using the fitted model for prediction.</li>
<li>Explain how to calculate confidence and prediction intervals for new observations.</li>
<li>Discuss the importance of validating the model’s predictive performance on new data.</li>
</ul></li>
<li><strong>Advanced Topics</strong>:
<ul>
<li><strong>Hierarchical Linear Models</strong>: Briefly introduce hierarchical linear models (HLM) for nested data structures.</li>
</ul></li>
</ol>
<p>General Suggestions</p>
<ol type="1">
<li><strong>Visual Aids</strong>: Use diagrams and flowcharts to explain complex concepts like multicollinearity, interaction effects, and model selection processes.</li>
<li><strong>Examples and Exercises</strong>: Provide plenty of examples and exercises at the end of each section to reinforce learning and allow readers to practice.</li>
<li><strong>Summary and Key Takeaways</strong>: Include a summary and key takeaways at the end of each chapter to reinforce the main points.</li>
<li><strong>Glossary</strong>: Create a glossary of terms used in the chapter to help readers understand and reference key concepts.</li>
<li><strong>References and Further Reading</strong>: Provide references and suggestions for further reading to allow interested readers to delve deeper into specific topics.</li>
</ol>
<p>Outline with Additional Sections</p>
<ol type="1">
<li><strong>About the Data</strong></li>
<li><strong>Simple Linear Models</strong></li>
<li><strong>Multiple Linear Regression</strong>
<ul>
<li>Definition and Explanation</li>
<li>Hypothesis Testing</li>
<li>Assumptions of MLR</li>
</ul></li>
<li><strong>Dealing with Multicollinearity</strong>
<ul>
<li>Explanation</li>
<li>VIF Analysis</li>
<li>Regularization Techniques</li>
</ul></li>
<li><strong>Forward Selection</strong>
<ul>
<li>Purpose and Explanation</li>
<li>Using <code>stepAIC()</code></li>
</ul></li>
<li><strong>Interpreting Coefficients in MLR</strong>
<ul>
<li>Continuous Predictors</li>
<li>Categorical Predictors</li>
<li>Interaction Terms</li>
</ul></li>
<li><strong>Added-Variable Plots (Partial Regression Plots)</strong>
<ul>
<li>What They Are</li>
<li>How to Use Them</li>
</ul></li>
<li><strong>Understanding the Model Fit</strong>
<ul>
<li>Interpreting <code>summary()</code></li>
<li>Interpreting <code>anova()</code></li>
<li>Model Selection Criteria</li>
</ul></li>
<li><strong>Model Diagnostics</strong>
<ul>
<li>Component Plus Residual Plots</li>
<li>Diagnostic Plots of Final Model</li>
<li>Dealing with Outliers and Influential Points</li>
</ul></li>
<li><strong>Model Validation and Cross-Validation</strong>
<ul>
<li>Train-Test Split</li>
<li>k-Fold Cross-Validation</li>
</ul></li>
<li><strong>Consider the Effect of Bioregional Classification</strong>
<ul>
<li>Including Categorical Predictors</li>
</ul></li>
<li><strong>Practical Applications and Case Studies</strong>
<ul>
<li>Real-World Examples</li>
</ul></li>
<li><strong>Summary and Key Takeaways</strong></li>
<li><strong>Glossary</strong></li>
<li><strong>References and Further Reading</strong></li>
</ol>
</section>
<section id="polynomial-regression" class="level4">
<h4 class="anchored" data-anchor-id="polynomial-regression">2.3. Polynomial Regression</h4>
<ul>
<li><strong>R Function:</strong> <code>lm()</code> (include polynomial terms as predictors)</li>
<li><strong>Data Requirements:</strong> Continuous outcome, continuous predictor.</li>
<li><strong>Assumptions:</strong> Same as SLR.</li>
<li><strong>Diagnostics:</strong> Same as SLR.</li>
<li><strong>If Assumptions Fail:</strong> Higher-order polynomial terms, splines, or consider non-linear models (Section 5).</li>
</ul>
</section>
<section id="x-regularisation" class="level4">
<h4 class="anchored" data-anchor-id="x-regularisation">2.x Regularisation</h4>
</section>
</section>
<section id="suggestions-for-improving-chapter-8-on-regularisation-techniques" class="level3">
<h3 class="anchored" data-anchor-id="suggestions-for-improving-chapter-8-on-regularisation-techniques">Suggestions for Improving Chapter 8 on Regularisation Techniques</h3>
<ol start="6" type="1">
<li><p><strong>Examples and Exercises:</strong></p>
<ul>
<li><strong>Additional Examples</strong>: Add more examples that cover a variety of datasets and scenarios, including both synthetic and real-world data.</li>
<li><strong>Exercises</strong>: Include exercises at the end of the chapter for students to practice implementing regularisation techniques, complete with solutions and explanations.</li>
</ul></li>
</ol>
<section id="analysis-of-covariance-ancova" class="level4">
<h4 class="anchored" data-anchor-id="analysis-of-covariance-ancova">2.4. Analysis of Covariance (ANCOVA)</h4>
<ul>
<li><strong>R Function:</strong> <code>lm()</code>, use a categorical predictor for group and a continuous predictor for the covariate.</li>
<li><strong>Data Requirements:</strong> Continuous outcome, categorical grouping variable, continuous covariate.</li>
<li><strong>Assumptions:</strong> Same as MLR.</li>
<li><strong>Diagnostics:</strong> Same as MLR.</li>
<li><strong>If Assumptions Fail:</strong> Same as MLR.</li>
</ul>
</section>
</section>
<section id="logistic-regression-for-binary-outcomes" class="level3">
<h3 class="anchored" data-anchor-id="logistic-regression-for-binary-outcomes">3. Logistic Regression for Binary Outcomes</h3>
<ul>
<li><strong>R Function:</strong> <code>glm(..., family = binomial)</code></li>
<li><strong>Data Requirements:</strong> Binary outcome, continuous or categorical predictors.</li>
<li><strong>Assumptions:</strong> Linear relationship between the log-odds of the outcome and predictors.</li>
<li><strong>Diagnostics:</strong> Check for influential observations, multicollinearity, and overall model fit.</li>
<li><strong>If Assumptions Fail:</strong> Consider interactions, alternative link functions (probit, complementary log-log) in <code>glm()</code>, or non-linear logistic regression.</li>
<li><strong>Model Selection:</strong> Stepwise regression, regularization techniques, information criteria (AIC, BIC).</li>
</ul>
</section>
<section id="generalised-linear-models-glms" class="level3">
<h3 class="anchored" data-anchor-id="generalised-linear-models-glms">4. Generalised Linear Models (GLMs)</h3>
<p>GLMs extend linear models to handle non-normal response distributions using link functions and exponential family distributions.</p>
<section id="poisson-regression" class="level4">
<h4 class="anchored" data-anchor-id="poisson-regression">4.1. Poisson Regression</h4>
<ul>
<li><strong>R Function:</strong> <code>glm(..., family = poisson)</code></li>
<li><strong>Data Requirements:</strong> Count outcome, continuous or categorical predictors.</li>
<li><strong>Assumptions:</strong> Equidispersion (variance equals the mean).</li>
<li><strong>Diagnostics:</strong> Check for overdispersion, excess zeros, and overall model fit.</li>
<li><strong>If Assumptions Fail:</strong> Negative binomial regression (<code>glm.nb()</code> in MASS package, overdispersion), zero-inflated models (<code>zeroinfl()</code> in pscl package, excess zeros).</li>
</ul>
</section>
<section id="beta-regression" class="level4">
<h4 class="anchored" data-anchor-id="beta-regression">4.2. Beta Regression</h4>
<ul>
<li><strong>R Function:</strong> <code>betareg()</code> in betareg package</li>
<li><strong>Data Requirements:</strong> Proportional outcome (0 &lt; y &lt; 1), continuous or categorical predictors.</li>
<li><strong>Assumptions:</strong> Outcome values within (0,1), potentially non-constant variance.</li>
<li><strong>Diagnostics:</strong> Check for overall model fit, influential observations, and residual analysis.</li>
<li><strong>If Assumptions Fail:</strong> Transformations, consider alternative link functions, or zero/one-inflated beta regression.</li>
</ul>
</section>
</section>
<section id="non-linear-models" class="level3">
<h3 class="anchored" data-anchor-id="non-linear-models">5. Non-Linear Models</h3>
<p>If the assumptions of linear or generalized linear models are violated and transformations or alternative link functions do not resolve the issues, consider non-linear models such as:</p>
<section id="non-linear-least-squares-nls" class="level4">
<h4 class="anchored" data-anchor-id="non-linear-least-squares-nls">5.1. Non-Linear Least Squares (NLS)</h4>
<ul>
<li><strong>R Function:</strong> <code>nls()</code> (for non-linear regression models with user-specified functions)</li>
<li><strong>Data Requirements:</strong> Continuous outcome, continuous predictors.</li>
<li><strong>Assumptions:</strong> Appropriate functional form, normality, and homoscedasticity of residuals.</li>
<li><strong>Diagnostics:</strong> Check residual plots, normality of residuals, and leverage/influence points.</li>
</ul>
</section>
<section id="non-linear-mixed-effects-models-nlmes" class="level4">
<h4 class="anchored" data-anchor-id="non-linear-mixed-effects-models-nlmes">5.2. Non-Linear Mixed-Effects Models (NLMEs)</h4>
<ul>
<li><strong>R Function:</strong> <code>nlme()</code> in nlme package (for non-linear mixed-effects models with user-specified functions)</li>
<li><strong>Data Requirements:</strong> Continuous outcome, continuous predictors, potentially with nested or hierarchical data structures.</li>
<li><strong>Assumptions:</strong> Appropriate functional form, normality, and homoscedasticity of residuals, correct specification of random effects structure.</li>
<li><strong>Diagnostics:</strong> Check residual plots, normality of residuals, and leverage/influence points, assess random effects structure.</li>
</ul>
</section>
<section id="regression-trees-and-random-forests" class="level4">
<h4 class="anchored" data-anchor-id="regression-trees-and-random-forests">5.3. Regression Trees and Random Forests</h4>
<ul>
<li><strong>R Packages:</strong> rpart, randomForest</li>
<li><strong>Data Requirements:</strong> Continuous, binary, or categorical outcome, continuous or categorical predictors.</li>
<li><strong>Advantages:</strong> Automatically handles non-linear relationships, variable interactions, and missing data.</li>
<li><strong>Limitations:</strong> Interpretability can be challenging, potential overfitting.</li>
</ul>
</section>
<section id="generalized-additive-models-gams-and-generalized-additive-mixed-models-gamms" class="level4">
<h4 class="anchored" data-anchor-id="generalized-additive-models-gams-and-generalized-additive-mixed-models-gamms">5.4. Generalized Additive Models (GAMs) and Generalized Additive Mixed Models (GAMMs)</h4>
<ul>
<li><strong>R Packages:</strong> mgcv, gamm4</li>
<li><strong>Data Requirements:</strong> Continuous, binary, or categorical outcome, continuous or categorical predictors, potentially with nested or hierarchical data structures.</li>
<li><strong>Advantages:</strong> Flexible modeling of non-linear relationships using smoothing functions, can handle mixed-effects structures.</li>
<li><strong>Limitations:</strong> Interpretation can be challenging, potential overfitting.</li>
</ul>
</section>
<section id="neural-networks" class="level4">
<h4 class="anchored" data-anchor-id="neural-networks">5.5. Neural Networks</h4>
<ul>
<li><strong>R Packages:</strong> nnet, keras, tensorflow</li>
<li><strong>Data Requirements:</strong> Continuous, binary, or categorical outcome, continuous or categorical predictors.</li>
<li><strong>Advantages:</strong> Powerful for capturing complex non-linear relationships, can handle large datasets.</li>
<li><strong>Limitations:</strong> Interpretability is limited, can be computationally intensive, prone to overfitting.</li>
</ul>
</section>
<section id="support-vector-machines-svms" class="level4">
<h4 class="anchored" data-anchor-id="support-vector-machines-svms">5.6. Support Vector Machines (SVMs)</h4>
<ul>
<li><strong>R Packages:</strong> e1071, kernlab</li>
<li><strong>Data Requirements:</strong> Continuous or binary outcome, continuous or categorical predictors.</li>
<li><strong>Advantages:</strong> Effective for high-dimensional data, can handle non-linear relationships through kernel functions.</li>
<li><strong>Limitations:</strong> Interpretability is limited, sensitive to parameter tuning.</li>
</ul>
</section>
</section>
<section id="additional-considerations" class="level3">
<h3 class="anchored" data-anchor-id="additional-considerations">6. Additional Considerations</h3>
<ul>
<li><strong>Mixed-Effects Models:</strong> For hierarchical or nested data structures (e.g., repeated measures, clustered data), consider mixed-effects models (linear mixed models, generalized linear mixed models) using <code>lme4</code> package or <code>nlme</code> package for non-linear mixed-effects models.</li>
<li><strong>Time Series Models:</strong> For data collected over time, explore time series models (e.g., ARIMA, exponential smoothing, state-space models).</li>
<li><strong>Survival Analysis Models:</strong> For modeling time-to-event data or censored data, consider survival analysis techniques (e.g., Cox proportional hazards model, accelerated failure time models).</li>
</ul>
</section>
<section id="correlation" class="level3">
<h3 class="anchored" data-anchor-id="correlation">7. Correlation</h3>
<ul>
<li><strong>R Functions:</strong> <code>cor()</code>, <code>cor.test()</code> (for significance testing)</li>
<li><strong>Data Requirements:</strong> Two continuous variables.</li>
<li><strong>Types:</strong> Pearson’s (parametric), Spearman’s rank (non-parametric), Kendall’s tau (non-parametric).</li>
<li><strong>Interpretation:</strong>
<ul>
<li>Pearson’s: Linear relationship, assumes normality and homoscedasticity.</li>
<li>Spearman’s: Monotonic relationship, robust to outliers.</li>
<li>Kendall’s: Monotonic relationship, robust to outliers and tied ranks.</li>
</ul></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>